<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/Zinus/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/Zinus/" rel="alternate" type="text/html" hreflang="en" /><updated>2025-09-10T23:37:56+09:00</updated><id>http://localhost:4000/Zinus/feed.xml</id><title type="html">Zinus Tech Blog</title><subtitle>Engineering stories and insights from the Zinus team</subtitle><entry><title type="html">Wonder-Server: Public API gateway powering pickups, feeds, and growth</title><link href="http://localhost:4000/Zinus/posts/2025/09/10/wonder-server-architecture-and-apis/" rel="alternate" type="text/html" title="Wonder-Server: Public API gateway powering pickups, feeds, and growth" /><published>2025-09-10T00:00:00+09:00</published><updated>2025-09-10T00:00:00+09:00</updated><id>http://localhost:4000/Zinus/posts/2025/09/10/wonder-server-architecture-and-apis</id><content type="html" xml:base="http://localhost:4000/Zinus/posts/2025/09/10/wonder-server-architecture-and-apis/"><![CDATA[<p>Zinus Wonder-Server (WAPI) is our public-facing API layer that brokers trusted access between external systems and our Shopify stores. It centralizes cross-cutting concerns like HTTPS enforcement, CORS, rate limiting, authentication/authorization, and integrates with external providers for email, growth, and compliance workflows.</p>

<h3 id="highlights">Highlights</h3>
<ul>
  <li>Enforces HTTPS, CORS allowlist per domain, and rate limiting in production</li>
  <li>JWT-protected private routes with scope-based authorization</li>
  <li>Shopify Admin GraphQL integration for order reads/writes</li>
  <li>LoadUp GraphQL integration for California mattress/box-spring pickups</li>
  <li>Growth utilities: Klaviyo subscription and back-in-stock proxy</li>
  <li>Operational utilities: product feed, eBay integration, email relay</li>
</ul>

<h3 id="history--ownership">History &amp; ownership</h3>
<ul>
  <li>Oct 2019 ‚Üí Oct 2021: Initial build and maintenance by Gabe (Gabriel) Nu√±ez.</li>
  <li>Since Oct 2021: Maintenance and enhancements by Yong Wan Song and Daniel Carroll.</li>
  <li>DevOps: Junkuk (Mason) Kim manages infrastructure and operations.</li>
</ul>

<h3 id="architecture">Architecture</h3>

<div class="mermaid">
flowchart LR
  A[Storefront/Shogun] --&gt; B[Ingress HTTP]
  C[Shopify Webhooks] --&gt; B
  D[Ops tools] --&gt; B

  B --&gt; E[CORS allowlist]
  E --&gt; F[Rate limit 15m 300IP]
  F --&gt; G[Public routes]
  F --&gt; H[Private routes]
  H --&gt; I[express-jwt]
  I --&gt; J[checkScopeAccess]

  G --&gt; G1[GET /api/product-feed]
  G --&gt; G2[POST /api/klaviyo/back-in-stock]
  G --&gt; G3[POST /api/klaviyo/subscribe]
  G --&gt; G4[POST /api/cj-track]
  G --&gt; G5[POST /api/rebuy-proxy]
  G --&gt; G6[POST /api/email]
  G --&gt; G7[GET /]
  G --&gt; G8[GET /api/ebay]

  J --&gt; H1[POST /api/pickup/schedule]
  J --&gt; H2[POST /api/pickup/cancel]
  J --&gt; H3[POST /api/pickup/refund]

  H1 --&gt; L[LoadUp GraphQL]
  H2 --&gt; L
  H3 --&gt; L
  H1 --&gt; S[Shopify Admin GraphQL]
  H3 --&gt; S
  G1 --&gt; S
  G2 --&gt; K[Klaviyo API]
  G3 --&gt; K
  G4 --&gt; CJ[CJ Affiliate]
  G5 --&gt; R[Rebuy API]
  G6 --&gt; M[Nodemailer]
  G8 --&gt; EBY[eBay API]
</div>

<h3 id="pickup-flow-sequence">Pickup flow (sequence)</h3>

<div class="mermaid">
sequenceDiagram
  participant SF as Storefront/Shogun
  participant WAPI as Wonder-Server
  participant LoadUp as LoadUp GraphQL
  participant Shopify as Shopify Admin GraphQL

  SF-&gt;&gt;WAPI: POST /api/pickup/schedule (order payload)
  WAPI-&gt;&gt;WAPI: Count mattress/box-spring items
  alt Pickup required (CA + attribute)
    WAPI-&gt;&gt;LoadUp: createPricedScheduleRequest (1..n)
    LoadUp--&gt;&gt;WAPI: scheduleRequest IDs
    WAPI-&gt;&gt;Shopify: orderUpdate(customAttributes += LoadUp IDs)
    Shopify--&gt;&gt;WAPI: OK
    WAPI--&gt;&gt;SF: 201 Created (Pickup request generated)
  else Not required
    WAPI--&gt;&gt;SF: 202 Accepted (No pickup required)
  end
</div>

<h3 id="request-pipeline-production">Request pipeline (production)</h3>
<p>1) Trust proxy and force HTTPS
2) Global rate limiting (15m window, 300 req/IP)
3) CORS validation against allowlist (<code class="language-plaintext highlighter-rouge">*.zinus.*</code>, Shogun, Mellow, etc.)
4) JWT validation for private routes, then scope-check middleware</p>

<pre><code class="language-12:33:c:/Zinus/Zinus/Wonder-Server/server.js">if (isProduction) {
  app.enable('trust proxy');
  app.use(function (req, res, next) {
    if (req.secure) { return next(); } else { return res.redirect('https://' + req.headers.host + req.url); }
  });
  const limiter = rateLimit({ windowMs: 15 * 60 * 1000, max: 300 });
  app.use(limiter);
}
</code></pre>

<h3 id="security-model">Security model</h3>
<ul>
  <li>Public endpoints: health, product feed, some growth endpoints</li>
  <li>Private endpoints: protected by <code class="language-plaintext highlighter-rouge">express-jwt</code> and <code class="language-plaintext highlighter-rouge">checkScopeAccess([...])</code></li>
</ul>

<pre><code class="language-1:20:c:/Zinus/Zinus/Wonder-Server/middleware/auth.js">exports.checkScopeAccess = (requiredScopes) =&gt; {
  return (req, res, next) =&gt; {
    if (isProduction) {
      const token = req.user;
      token.scopes.forEach((scope) =&gt; {
        if (requiredScopes.find((requiredScope) =&gt; requiredScope === scope)) {
          return next();
        } else {
          return res.status(401).json({ code: '401', error: 'Insufficient permissions' });
        }
      });
    } else { return next(); }
  };
};
</code></pre>

<h3 id="key-capabilities">Key capabilities</h3>

<h4 id="1-california-pickup-orchestration-loadup--shopify">1) California pickup orchestration (LoadUp + Shopify)</h4>
<ul>
  <li>Robust item classifier detects mattresses, box springs, and paired combos, transforming Shopify webhooks into actionable pickup requests.
    <pre><code class="language-12:69:c:/Zinus/Zinus/Wonder-Server/routes/pickup.js">const countPickupItems = (lineItems, quantityKey) =&gt; {
let mattressCount = 0; let boxSpringCount = 0; let mattressBoxCombo = 0;
lineItems.forEach((item) =&gt; {
  const titleIncludes = (text) =&gt; item.title.toLowerCase().includes(text);
  if (titleIncludes('box spring')) { boxSpringCount += item[quantityKey]; }
  else if (titleIncludes('mattress') &amp;&amp; !titleIncludes('topper') &amp;&amp; !titleIncludes('cover') &amp;&amp; !titleIncludes('pad')) {
    mattressCount += item[quantityKey];
  }
});
if (mattressCount &amp;&amp; boxSpringCount) { /* normalize into combos when counts align */ }
return { mattresses: mattressCount, boxSprings: boxSpringCount, comboCount: mattressBoxCombo, totalCount: mattressCount + boxSpringCount + mattressBoxCombo };
};
</code></pre>
  </li>
  <li>Schedule flow: gate by state and order attribute; persist LoadUp IDs back to Shopify for traceability/idempotency.
    <pre><code class="language-71:106:c:/Zinus/Zinus/Wonder-Server/routes/pickup.js">router.post('/schedule', async (req, res) =&gt; {
const { note_attributes, shipping_address, line_items, email, id } = req.body;
const pickupAttribute = note_attributes.find((a) =&gt; a.name === 'Pickup Requested');
const pickupRequired = pickupAttribute &amp;&amp; pickupAttribute.value.toLowerCase() === 'true';
if ((shipping_address.province === 'California' || shipping_address.province_code === 'CA') &amp;&amp; pickupRequired) {
  const pickupItemCount = countPickupItems(line_items, 'quantity');
  const pickupIDs = await generatePickupRequests({ /* address &amp; counts */ });
  await addPickupAttrToOrder({ orderID: id, pickupIDs: pickupIDs.join(',') });
  return res.status(201).json({ code: '201', response: 'Pickup request generated.' });
} else { return res.status(202).json({ code: '202', response: 'No pickup required.' }); }
});
</code></pre>
  </li>
  <li>Refund flow: cancel existing pickups and reschedule with the net quantities.
    <pre><code class="language-180:247:c:/Zinus/Zinus/Wonder-Server/routes/pickup.js">router.post('/refund', async (req, res) =&gt; {
const { refund_line_items: refundedLineItems, order_id: orderID } = req.body;
if (refundedLineItems.length) {
  const shopifyOrder = await getShopifyOrderInfo(orderID);
  /* derive counts, cancelLoadup, regenerate, update order attr */
  return res.status(201).json({ code: '201', response: 'Cancelled pickup and made new one.' });
} else {
  return res.status(202).json({ code: '202', response: 'No item refunded.' });
}
});
</code></pre>
  </li>
  <li>LoadUp + Shopify GraphQL clients and mutations.
    <pre><code class="language-7:15:c:/Zinus/Zinus/Wonder-Server/routes/components/pickup/gql.js">exports.loadupGQLclient = (() =&gt; {
const gqlURL = isProduction ? this.loadupProdURL : this.loadupDevURL;
return new GraphQLClient(gqlURL, { headers: { 'X-Access-Token': process.env.LOADUP_ACCESS_TOKEN } });
})();
</code></pre>
    <pre><code class="language-17:36:c:/Zinus/Zinus/Wonder-Server/routes/components/pickup/gql.js">exports.createPickupRequest = gql`mutation createPricedScheduleRequest($inputs: CreatePricedScheduleRequestInputs!){ createPricedScheduleRequest(inputs:$inputs){ scheduleRequest{ id total } errorCode } }`;
exports.cancelPickupRequest = gql`mutation cancelScheduleRequest($inputs: CancelScheduleRequestInputs!){ cancelScheduleRequest(inputs:$inputs){ errorCode } }`;
</code></pre>
    <pre><code class="language-7:15:c:/Zinus/Zinus/Wonder-Server/routes/components/shopify/gql.js">exports.shopifyGQLclient = (() =&gt; { /* Admin GraphQL with X-Shopify-Access-Token */ })();
</code></pre>
    <pre><code class="language-17:29:c:/Zinus/Zinus/Wonder-Server/routes/components/shopify/gql.js">exports.mutateOrder = gql`mutation orderUpdate($input: OrderInput!){ orderUpdate(input:$input){ order{ id } userErrors{ field message } } }`;
</code></pre>
    <pre><code class="language-31:62:c:/Zinus/Zinus/Wonder-Server/routes/components/shopify/gql.js">exports.orderDetails = gql`query order($id: ID!){ order(id:$id){ name customAttributes{ key value } email fulfillable shippingAddress{ firstName lastName phone address1 address2 city province provinceCode zip } lineItems(first:50){ edges{ node{ title fulfillableQuantity } } } } }`;
</code></pre>
  </li>
</ul>

<h4 id="2-growth-and-personalization">2) Growth and personalization</h4>
<ul>
  <li>Klaviyo back-in-stock: transparent proxy to the Onsite component API.
    <pre><code class="language-5:12:c:/Zinus/Zinus/Wonder-Server/routes/klaviyo.js">router.post('/back-in-stock', async (req, res) =&gt; {
const response = await axios.post('https://a.klaviyo.com/onsite/components/back-in-stock/subscribe', req.body.data ? req.body.data : new URLSearchParams(req.body).toString());
return res.json(response.data);
});
</code></pre>
  </li>
  <li>Klaviyo marketing consent (bulk create job) with region-aware API key selection (EU vs US) inferred from Origin/Referrer.
    <pre><code class="language-27:56:c:/Zinus/Zinus/Wonder-Server/routes/klaviyo.js">const getKlaviyoKey = () =&gt; { /* parse Origin/Referrer; map domain to KLAVIYO_EU_KEY or KLAVIYO_KEY */ };
</code></pre>
    <pre><code class="language-58:86:c:/Zinus/Zinus/Wonder-Server/routes/klaviyo.js">const headers = { accept:'application/json', revision:'2024-02-15', 'content-type':'application/json', Authorization:`Klaviyo-API-Key ${getKlaviyoKey()}` };
const data = { data: { type:'profile-subscription-bulk-create-job', attributes:{ custom_source:'Web Signup', profiles:{ data:[{ type:'profile', attributes:{ email, subscriptions:{ email:{ marketing:{ consent:'SUBSCRIBED' } } } } }] } }, relationships:{ list:{ data:{ type:'list', id:listId } } } } };
</code></pre>
  </li>
  <li>Rebuy personalization proxy: server-side fetch with API key and passthrough, enabling storefront widgets without exposing secrets.
    <pre><code class="language-5:12:c:/Zinus/Zinus/Wonder-Server/routes/rebuy-prox.js">router.get('/', async (req, res) =&gt; { const { data_id, product_ids, variant_ids } = req.query; const key = process.env.REBUY_API_KEY; const url = `https://rebuyengine.com/api/v1/custom/id/${data_id}?key=${key}&amp;shopify_product_ids=${product_ids}&amp;shopify_variant_ids=${variant_ids}&amp;metafields=yes`; const response = await axios.get(url); return res.json(response.data); });
</code></pre>
  </li>
  <li>CJ Affiliate tracking: 13‚Äëmonth cookie on the apex domain for cross-subdomain attribution.
    <pre><code class="language-14:21:c:/Zinus/Zinus/Wonder-Server/routes/cj-track.js">res.cookie('cje', cjeventID, { domain: isProduction &amp;&amp; '.zinus.com', maxAge: thirteenMonths, httpOnly: false, secure: isProduction ? true : false });
</code></pre>
  </li>
</ul>

<h4 id="3-product-feed-generator-shopify-admin-rest">3) Product feed generator (Shopify Admin REST)</h4>
<ul>
  <li>Paginates via Link headers, filters non-sellable product types, and materializes variant-level rows with canonical image selection.
    <pre><code class="language-16:56:c:/Zinus/Zinus/Wonder-Server/routes/product-feed.js">for (product of response.data.products) {
const { body_html, title: productTitle, handle, images, variants, product_type, id: productId } = product;
if (product_type === 'Protection Plan' || product_type === 'Insurance') { continue; }
if (variants.length &gt; 1) {
  variants.forEach((variant) =&gt; {
    let variantImageId = variant.image_id; let variantImage = null;
    if (variantImageId) { const variantImageObj = images.find((image) =&gt; image.id === variantImageId); variantImage = variantImageObj?.src; }
    else if (!variantImageId &amp;&amp; images.length &gt; 0) { variantImage = images[0]?.src; }
    productFeed.push({ title: productId !== 7269091967039 ? `${productTitle} - ${variant.title}` : `${variant.title}`, id: variant.id, inventory_quantity: variant.inventory_quantity, description: convert(body_html), price: parseFloat(variant.price), link: `https://www.zinus.com/${product_type}/${handle}?variant=${variant.id}`, inventory_policy: 1, categories: [product_type], image_link: variantImage });
  });
} else {
  productFeed.push({ title: productTitle, id: variants[0].id, description: convert(body_html), inventory_quantity: variants[0].inventory_quantity, price: parseFloat(variants[0].price), link: `https://www.zinus.com/${product_type}/${handle}`, inventory_policy: 1, categories: [product_type], image_link: (images.length &gt; 0 &amp;&amp; images[0].src) || null });
}
}
</code></pre>
  </li>
</ul>

<h4 id="4-secure-email-relay-with-hcaptcha--locale-routing">4) Secure email relay with hCaptcha + locale routing</h4>
<ul>
  <li>Validates <code class="language-plaintext highlighter-rouge">hcaptcha</code> token, routes to country-specific support inboxes, handles attachments via Multer, and sets Reply-To to the customer email.
    <pre><code class="language-18:25:c:/Zinus/Zinus/Wonder-Server/routes/email.js">await axios.post('https://hcaptcha.com/siteverify', { secret: process.env.HCAPTCHA_SECRET, response: captchaToken });
</code></pre>
    <pre><code class="language-27:62:c:/Zinus/Zinus/Wonder-Server/routes/email.js">const originStoreUrl = req.header('Origin').split('www.')[1];
switch (originStoreUrl) { case 'zinus.jp': toEmail = 'customerservice-jp@zinus.com'; break; case 'zinus.com.au': toEmail = 'australianorders@zinus.com'; break; case 'zinus.fr': case 'zinus.com.de': case 'zinus.co.uk': toEmail = 'eusupport@zinus.com'; break; }
</code></pre>
    <pre><code class="language-68:79:c:/Zinus/Zinus/Wonder-Server/routes/email.js">const attachments = req.files &amp;&amp; req.files.file &amp;&amp; req.files.file.length &amp;&amp; req.files.file.map((item) =&gt; ({ filename: item.originalname, content: item.buffer }));
</code></pre>
    <pre><code class="language-86:93:c:/Zinus/Zinus/Wonder-Server/routes/email.js">await sendHTMLEmail({ toEmail, replyToEmail: customerEmail, emailSubject: `${emailSubject} - ${originStoreUrl}`, html: bodyLines.join('&lt;br /&gt;'), attachments });
</code></pre>
    <pre><code class="language-4:11:c:/Zinus/Zinus/Wonder-Server/utils/email/index.js">const transporter = nodemailer.createTransport({ host: 'smtp.gmail.com', port: 465, auth: { user: 'web-notifications@zinusinc.com', pass: process.env.GMAIL_PASSWORD } });
</code></pre>
    <pre><code class="language-22:31:c:/Zinus/Zinus/Wonder-Server/utils/email/index.js">exports.sendHTMLEmail = async (options) =&gt; { const info = await transporter.sendMail({ from: '"Zinus Robot ü§ñ" &lt;noreply@zinusinc.com&gt;', replyTo: options.replyToEmail, to: options.toEmail, subject: options.emailSubject, html: options.attachACat ? options.html + (await this.getCatImage()) : options.html, attachments: options.attachments || [] }); return info.messageId; };
</code></pre>
  </li>
</ul>

<h4 id="5-security-and-resilience-middleware-production">5) Security and resilience middleware (production)</h4>
<ul>
  <li>Request timeout, HTTPS redirect, CORS allowlist, rate limiting, JWT validation, and scoped authorization.
    <pre><code class="language-34:41:c:/Zinus/Zinus/Wonder-Server/server.js">app.use(timeout('20s'));
app.use(express.json());
const upload = multer();
app.get('/', (req, res) =&gt; { return res.status(200).send(welcomeMessage); });
</code></pre>
    <pre><code class="language-42:83:c:/Zinus/Zinus/Wonder-Server/server.js">const whitelist = [ 'https://www.zinus.com', /* ...regional domains... */ 'https://mellow-home.com.au' ];
const corsOptions = { origin: function (origin, callback) { if (whitelist.indexOf(origin) !== -1 || !origin) { callback(null, true); } else { callback(new Error('Not allowed by CORS')); } } };
</code></pre>
    <pre><code class="language-96:99:c:/Zinus/Zinus/Wonder-Server/server.js">const cpUpload = upload.fields([{ name: 'file', maxCount: 5 }]);
app.use('/api/email', [cors(isProduction &amp;&amp; corsOptions), cpUpload], require('./routes/email'));
</code></pre>
    <pre><code class="language-104:121:c:/Zinus/Zinus/Wonder-Server/server.js">app.use(jwt({ secret: process.env.JWT_SECRET, algorithms: ['HS256'], credentialsRequired: true, getToken: function fromHeaderOrQuerystring(req){ if (req.headers.authorization &amp;&amp; req.headers.authorization.split(' ')[0] === 'Bearer') { return req.headers.authorization.split(' ')[1]; } if (req.query &amp;&amp; req.query.token) { return req.query.token; } return null; } }));
</code></pre>
    <pre><code class="language-122:128:c:/Zinus/Zinus/Wonder-Server/server.js">app.use((err, req, res, next) =&gt; { if (err.name === 'UnauthorizedError') { return res.status(401).json({ code: '401', error: err.message }); } });
</code></pre>
    <pre><code class="language-132:135:c:/Zinus/Zinus/Wonder-Server/server.js">app.use((req, res) =&gt; { return res.status(404).json({ code: '404', error: 'Whoops, that path does not exist :o' }); });
</code></pre>
  </li>
</ul>

<h3 id="operational-learnings">Operational learnings</h3>
<ul>
  <li>Keep allowlists current across markets and staging domains</li>
  <li>Use JWT scopes for least-privilege integrations</li>
  <li>Persist third-party IDs back to Shopify for observability and idempotency</li>
  <li>Cap rate limits above storefront AJAX bursts but below abuse thresholds</li>
</ul>

<p>If you‚Äôd like a deeper dive into any module, ping the team in Slack.</p>]]></content><author><name>Zinus Engineering</name></author><category term="shopify" /><category term="api" /><category term="nodejs" /><category term="graphql" /><category term="infrastructure" /><category term="integrations" /><summary type="html"><![CDATA[Zinus Wonder-Server (WAPI) is our public-facing API layer that brokers trusted access between external systems and our Shopify stores. It centralizes cross-cutting concerns like HTTPS enforcement, CORS, rate limiting, authentication/authorization, and integrates with external providers for email, growth, and compliance workflows.]]></summary></entry><entry><title type="html">Zinus Embedded App: Remix + Shopify Functions powering checkout experiences</title><link href="http://localhost:4000/Zinus/posts/2025/09/10/embedded-app-architecture-checkout-extensions/" rel="alternate" type="text/html" title="Zinus Embedded App: Remix + Shopify Functions powering checkout experiences" /><published>2025-09-10T00:00:00+09:00</published><updated>2025-09-10T00:00:00+09:00</updated><id>http://localhost:4000/Zinus/posts/2025/09/10/embedded-app-architecture-checkout-extensions</id><content type="html" xml:base="http://localhost:4000/Zinus/posts/2025/09/10/embedded-app-architecture-checkout-extensions/"><![CDATA[<p>Our Embedded App is a Remix-based Shopify application that centralizes admin UX, data, and a suite of checkout extensions for compliance and conversion. It ships with Polaris UI, Prisma session storage, and multiple UI Extensions that run natively in Shopify Checkout.</p>

<h3 id="stack">Stack</h3>
<ul>
  <li>Remix + Vite (Node ‚â•16)</li>
  <li><code class="language-plaintext highlighter-rouge">@shopify/shopify-app-remix</code> for auth, webhooks, session</li>
  <li>Polaris for admin UI</li>
  <li>Prisma (session storage via <code class="language-plaintext highlighter-rouge">PrismaSessionStorage</code>)</li>
  <li>App/Checkout UI Extensions (React runtime)</li>
</ul>

<pre><code class="language-1:21:c:/Zinus/Zinus/ZinusEmbeddedApp/app/shopify.server.js">const shopify = shopifyApp({
  apiKey: process.env.SHOPIFY_API_KEY,
  apiSecretKey: process.env.SHOPIFY_API_SECRET || "",
  apiVersion: ApiVersion.April24,
  scopes: process.env.SCOPES?.split(","),
  sessionStorage: new PrismaSessionStorage(prisma),
  webhooks: { APP_UNINSTALLED: { deliveryMethod: DeliveryMethod.Http, callbackUrl: "/webhooks" } },
  hooks: { afterAuth: async ({ session }) =&gt; { shopify.registerWebhooks({ session }); } },
});
</code></pre>

<h3 id="architecture">Architecture</h3>

<pre><code class="language-mermaid">flowchart LR
  Admin[Shopify Admin] --&gt;|Embedded| RemixApp
  RemixApp[Remix app\nPolaris UI + Prisma] --&gt; Shopify[Shopify APIs]
  subgraph Checkout
    CE1[Contiguous states restriction]
    CE2[Recycle fee auto-line]
    CE3[Countdown banner]
    CE4[Delivery info/metafields]
  end
  Checkout ===&gt; Shopify
</code></pre>

<h3 id="checkout-extensions">Checkout extensions</h3>

<p>1) Contiguous states restriction</p>
<ul>
  <li>Blocks the buyer journey if the address is a non-contiguous US location</li>
</ul>

<pre><code class="language-12:21:c:/Zinus/Zinus/ZinusEmbeddedApp/extensions/contiguous-states-restriction/src/Checkout.jsx">useBuyerJourneyIntercept(() =&gt; {
  return shippingAddress?.provinceCode &amp;&amp; restrictedLocations.includes(shippingAddress?.provinceCode)
    ? { behavior: 'block', reason: 'We currently do not ship to your location.', errors: [{ message: 'We ship to the 48 contiguous states...', target: '$.cart.deliveryGroups[0].deliveryAddress.provinceCode' }] }
    : { behavior: 'allow' };
});
</code></pre>

<p>2) Recycling fee automation</p>
<ul>
  <li>Detects mattresses/box-springs and auto-syncs the correct fee variant per state</li>
</ul>

<pre><code class="language-34:58:c:/Zinus/Zinus/ZinusEmbeddedApp/extensions/recycle-fee/src/Checkout.jsx">function checkForRecycleFee() {
  const provinceCode = shippingAddress?.provinceCode;
  if (feeLocations.includes(provinceCode)) {
    // match fee variant for province, reconcile quantity vs. cart contents
    if (feeInCart &amp;&amp; feeInCart.merchandise.selectedOptions[0].value !== provinceCode) {
      handleRemoveFromCart(feeInCart.id, feeInCart.quantity);
      handleAddToCart(feeId, feeInCart.quantity);
    }
    if (feeNeeded &gt; feeFound) { handleAddToCart(feeId, difference); }
  } else { /* remove any fee lines */ }
}
</code></pre>

<p>3) Checkout countdown banner</p>
<ul>
  <li>Configurable content via extension settings; shows time remaining</li>
</ul>

<pre><code class="language-12:26:c:/Zinus/Zinus/ZinusEmbeddedApp/extensions/zinus-checkout-countdown/src/Checkout.jsx">const [timeLeft, setTimeLeft] = useState(600);
useEffect(() =&gt; { if (!timeLeft) return; const id = setInterval(() =&gt; setTimeLeft(timeLeft - 1), 1000); return () =&gt; clearInterval(id); }, [timeLeft]);
</code></pre>

<p>4) Delivery/misc checkout enrichments</p>
<ul>
  <li>Reads product metafields and surfaces data in checkout context</li>
</ul>

<pre><code class="language-27:41:c:/Zinus/Zinus/ZinusEmbeddedApp/extensions/zinus-checkout-delivery/src/Checkout.jsx">const productId = cartLineTarget?.merchandise?.product?.id;
query(`query { product(id: "${productId}") { variants(first: 25) { edges { node { metafield(namespace: "custom", key: "mattress_height") { value } } } } } }`) ...
</code></pre>

<h3 id="operational-notes">Operational notes</h3>
<ul>
  <li>Use <code class="language-plaintext highlighter-rouge">login</code>/<code class="language-plaintext highlighter-rouge">authenticate</code> helpers exclusively for embedded navigation and API calls</li>
  <li>Keep <code class="language-plaintext highlighter-rouge">ApiVersion</code> aligned with current Admin API; update <code class="language-plaintext highlighter-rouge">restResources</code> accordingly</li>
  <li>Prisma session DB must be shared across instances (SQLite only OK for single instance)</li>
  <li>Extensions should fail ‚Äúclosed‚Äù (block or remove lines) to protect compliance</li>
</ul>

<h3 id="why-this-matters">Why this matters</h3>
<p>By pairing an embedded admin app with checkout-native extensions, we deliver merchant control and strict checkout enforcement without slowing down the storefront. Compliance flows (like recycling fees and shipping restrictions) run client-side within Shopify‚Äôs secure runtime; data-heavy or cross-system tasks stay server-side in the app.</p>]]></content><author><name>Zinus Engineering</name></author><category term="shopify" /><category term="remix" /><category term="polaris" /><category term="prisma" /><category term="checkout" /><category term="extensions" /><summary type="html"><![CDATA[Our Embedded App is a Remix-based Shopify application that centralizes admin UX, data, and a suite of checkout extensions for compliance and conversion. It ships with Polaris UI, Prisma session storage, and multiple UI Extensions that run natively in Shopify Checkout.]]></summary></entry><entry><title type="html">Keeping Outlook Mailboxes Lean with n8n Our ‚ÄúSelf-Cleaning Sent Items‚Äù Workflow</title><link href="http://localhost:4000/Zinus/posts/2025/09/05/keeping-outlook-mailboxes-lean-with-n8n/" rel="alternate" type="text/html" title="Keeping Outlook Mailboxes Lean with n8n Our ‚ÄúSelf-Cleaning Sent Items‚Äù Workflow" /><published>2025-09-05T00:00:00+09:00</published><updated>2025-09-05T00:00:00+09:00</updated><id>http://localhost:4000/Zinus/posts/2025/09/05/keeping-outlook-mailboxes-lean-with-n8n</id><content type="html" xml:base="http://localhost:4000/Zinus/posts/2025/09/05/keeping-outlook-mailboxes-lean-with-n8n/"><![CDATA[<blockquote>
  <p><strong>TL;DR:</strong> We built an n8n workflow that runs nightly, checks an Outlook mailbox‚Äôs storage, and‚Äîif usage is above 50%‚Äîpermanently deletes the oldest messages from <strong>Sent Items</strong> until usage drops below 49%. It then emails a status report. Zero manual cleanup. Zero drama.</p>
</blockquote>

<hr />

<h2 id="why-we-built-this">Why we built this</h2>

<p>Mailbox quotas shouldn‚Äôt be a part-time job. We send a <em>lot</em> of automated emails, which means <strong>Sent Items</strong> can quietly balloon and tip an otherwise healthy mailbox over quota. We wanted a simple, deterministic guardrail that:</p>

<ul>
  <li>Enforces a <strong>hard ceiling</strong> on mailbox growth</li>
  <li>Requires <strong>no manual intervention</strong></li>
  <li>Leaves <strong>inbox and critical folders untouched</strong></li>
</ul>

<p>n8n was a perfect fit: visual, automatable, and great at orchestrating API calls with guardrails.</p>

<hr />

<h2 id="what-the-workflow-does-at-a-glance">What the workflow does (at a glance)</h2>

<ol>
  <li><strong>Runs nightly at midnight</strong> via <code class="language-plaintext highlighter-rouge">Schedule</code> trigger.</li>
  <li><strong>Checks mailbox usage</strong> through Microsoft Graph (read-only usage metrics).</li>
  <li><strong>If usage ‚â• 50%</strong>, it:
    <ul>
      <li>Pulls <strong>oldest Sent Items</strong> in batches</li>
      <li>Permanently deletes those messages</li>
      <li>Re-checks usage and repeats until <strong>&lt; 49%</strong></li>
    </ul>
  </li>
  <li><strong>Sends a completion email</strong> with the final usage and how many messages were deleted.</li>
</ol>

<p>We intentionally use <strong>49%</strong> as the target to avoid bobbling around the threshold on the next run.</p>

<hr />

<h2 id="why-high-utilization-hurts">Why high utilization hurts</h2>

<ul>
  <li><strong>At 100% quota, mail flow stops.</strong> Hitting the maximum quota typically blocks <strong>sending</strong> and can block <strong>receiving</strong> as well‚Äîexactly the kind of outage we don‚Äôt want.</li>
  <li><strong>Client performance degrades.</strong> Large stores make desktop and mobile clients slower to start, search, and sync; local caches (OST/PST) swell and get more error-prone.</li>
  <li><strong>Search &amp; discovery slow down.</strong> Bigger mailboxes increase indexing time and make eDiscovery/compliance searches more expensive and sluggish.</li>
  <li><strong>Risk of missed automations.</strong> If quotas block mail, downstream processes that rely on email (alerts, approvals, receipts) can silently fail.</li>
  <li><strong>Operational overhead spikes.</strong> Backups and restores take longer; support escalations go up; users resort to manual triage instead of real work.</li>
</ul>

<hr />

<h2 id="node-by-node-tour">Node-by-node tour</h2>

<blockquote>
  <p>Naming below mirrors the canvas, with sensitive values abstracted.</p>
</blockquote>

<ul>
  <li><strong>Schedule Trigger</strong> ‚Äì Fires at <code class="language-plaintext highlighter-rouge">00:00</code> every day.</li>
  <li><strong>Get All Folders</strong> ‚Üí <strong>Get usage</strong> ‚Äì Looks up folder IDs and retrieves usage stats (no secrets hard-coded).</li>
  <li><strong>Check if &gt; 50%</strong> ‚Äì Branches on usage. If false, we short-circuit: log + notify.</li>
  <li><strong>Get Sent Items</strong> ‚Üí <strong>Get Items List</strong> ‚Äì Locates <strong>Sent Items</strong> and fetches a <strong>sorted oldest-first</strong> batch of IDs.</li>
  <li><strong>Batch Emails</strong> ‚Üí <strong>Permanent Delete Emails</strong> ‚Äì Deletes in controlled chunks; a brief <strong>Wait (0.1s)</strong> smooths bursts and avoids throttling.</li>
  <li><strong>Get updated usage</strong> ‚Äì Re-reads usage to see if we‚Äôve crossed below <strong>49%</strong>.</li>
  <li><strong>Return input / chooseBranch</strong> ‚Äì Loop if still above threshold and no errors; otherwise summarize.</li>
  <li><strong>Previous usage &amp; Deleted Emails &amp; Errors‚Ä¶</strong> ‚Üí <strong>Get deleted count</strong> ‚Üí <strong>Send a message</strong> ‚Äì Aggregates usage, deletion counts, and errors into a tidy status email.</li>
</ul>

<blockquote>
  <p>There‚Äôs also a small safety branch labeled <strong>‚ÄúIf Usage &gt; 40% &amp; No Errors‚Äù</strong> that keeps the loop resilient to transient reads and exits cleanly if anything looks off.</p>
</blockquote>

<hr />

<h2 id="the-control-loop-mermaid-flowchart">The control loop (Mermaid flowchart)</h2>

<pre><code class="language-mermaid">flowchart TD
  A[Schedule Trigger @ 00:00 daily] --&gt; B[Get mailbox usage]
  B --&gt;|usage &lt; 50%| C[Send status email: All good]:::done
  B --&gt;|usage ‚â• 50%| D[Init total_deleted = 0]

  D --&gt; E[Fetch oldest Sent Items batch]
  E --&gt; F{Any IDs?}
  F --&gt;|No| G[Send status email: No items to delete]:::done
  F --&gt;|Yes| H[Hard delete batch]

  H --&gt; I[Wait 100 ms]
  I --&gt; J[Re-check mailbox usage]
  J --&gt; K{usage ‚â• 49%?}
  K --&gt;|Yes| E
  K --&gt;|No| L[Send status email: Cleanup complete]:::done

  classDef done fill:#e8f5e9,stroke:#2e7d32,color:#2e7d32;
</code></pre>

<hr />

<h2 id="guardrails--good-manners">Guardrails &amp; good manners</h2>

<ul>
  <li><strong>Read-only before write-heavy</strong>: We don‚Äôt touch messages unless usage demands it.</li>
  <li><strong>Batching + back-off</strong>: Fixed-size deletes + a tiny pause keep API usage smooth and throttle-friendly.</li>
  <li><strong>Folder-scoped deletes only</strong>: Only <strong>Sent Items</strong> is pruned. Inbox and critical folders stay untouched.</li>
  <li><strong>Safe thresholds</strong>: The <code class="language-plaintext highlighter-rouge">50%/49%</code> band avoids thrash and keeps runs short.</li>
  <li><strong>Minimal permissions</strong>: Graph scopes are limited to what‚Äôs required for folder read + message delete.</li>
  <li><strong>Idempotent by design</strong>: If a run is interrupted, the next one simply re-evaluates usage and continues.</li>
</ul>

<h2 id="closing-thoughts">Closing thoughts</h2>

<p>This is one of those <em>‚Äúsmall but mighty‚Äù</em> automations: it quietly removes a class of operational noise. n8n made it simple to build a safe, auditable, and repeatable mailbox hygiene policy‚Äîwithout wiring up a bespoke service or doing cron yoga.</p>

<p>If you‚Äôre already using n8n for internal automations, this pattern <code class="language-plaintext highlighter-rouge">(measure ‚Üí batch ‚Üí verify ‚Üí report)</code> is reusable well beyond email. And if you‚Äôre not‚Ä¶ consider this your sign.</p>]]></content><author><name>Zinus Engineering</name></author><category term="outlook" /><category term="n8n" /><category term="microsoft-graph" /><category term="automation" /><category term="email" /><category term="quota-management" /><category term="workflows" /><summary type="html"><![CDATA[A nightly n8n workflow that enforces Outlook mailbox quotas‚Äîdeleting the oldest Sent Items until usage drops below 49%, preventing 100% lockups, and emailing a tidy report.]]></summary></entry><entry><title type="html">n8n on self-hosted servers to auto-cancel bot-generated warranty‚Äëonly Shopify orders</title><link href="http://localhost:4000/Zinus/posts/2025/09/03/n8n-shopify-anti-bot-cancellations/" rel="alternate" type="text/html" title="n8n on self-hosted servers to auto-cancel bot-generated warranty‚Äëonly Shopify orders" /><published>2025-09-03T00:00:00+09:00</published><updated>2025-09-03T00:00:00+09:00</updated><id>http://localhost:4000/Zinus/posts/2025/09/03/n8n-shopify-anti-bot-cancellations</id><content type="html" xml:base="http://localhost:4000/Zinus/posts/2025/09/03/n8n-shopify-anti-bot-cancellations/"><![CDATA[<p>This project documents how we built a self‚Äëhosted n8n workflow to automatically cancel malicious orders that contain only non-public warranty products (e.g., Mulberry, Route) or low‚Äëvalue $3 protection plans. Attackers were repeatedly creating these orders to pollute our sales signals and downstream operations. The workflow runs reliably in production and replaces a previous attempt with Shopify Flow.</p>

<h2 id="why-n8n-instead-of-shopify-flow">Why n8n instead of Shopify Flow</h2>

<ul>
  <li>Shopify Flow cannot cancel orders in our scenario.</li>
  <li>Our SAP integration sometimes pushes tracking first and marks orders as Fulfillment in progress, which blocks Flow from cancelling/refunding.</li>
  <li>Conflicts with Shopify‚Äôs built‚Äëin High‚Äërisk auto‚Äëcancel flow created race conditions and inconsistent states.</li>
  <li>n8n lets us orchestrate retries and call Shopify GraphQL directly, including fulfillment cancellation before order cancellation.</li>
</ul>

<h2 id="highlevel-behavior">High‚Äëlevel behavior</h2>

<ul>
  <li>Detect orders via Shopify <code class="language-plaintext highlighter-rouge">orders/create</code> webhook and a scheduled backfill (every 30 minutes).</li>
  <li>Inspect line items; if all items are tagged <code class="language-plaintext highlighter-rouge">SEARCHANISE_IGNORE</code>, treat the order as a warranty‚Äëonly/bot order.</li>
  <li>Attempt <code class="language-plaintext highlighter-rouge">orderCancel</code> via GraphQL.</li>
  <li>If the order has outstanding fulfillments, call <code class="language-plaintext highlighter-rouge">fulfillmentCancel</code>, wait briefly, then retry <code class="language-plaintext highlighter-rouge">orderCancel</code>.</li>
  <li>Send an operational email once handled.</li>
</ul>

<h2 id="diagram">Diagram</h2>

<pre><code class="language-mermaid">graph TD
  subgraph Triggers
    A["Shopify orders/create webhook"]
    B["Schedule trigger (every 30m), get recent orders"]
  end

  A --&gt; C["Get order"]
  B --&gt; D["Loop over recent orders"]
  D --&gt; C

  C --&gt; E["Split line items"]
  E --&gt; F["Fetch product for each item"]
  F --&gt; G{Product tags include: SEARCHANISE_IGNORE?}
  G --&gt;|yes| H["Mark item as __skip"]
  G --&gt;|no| I["Keep item"]
  H --&gt; J["Batch complete"]
  I --&gt; J

  J --&gt; K{All items skipped? warranty-only}
  K --&gt;|no| L["Do nothing"]
  K --&gt;|yes| M["GraphQL orderCancel"]

  M --&gt; N{Error: outstanding fulfillments?}
  N --&gt;|yes| O["GraphQL fulfillmentCancel"]
  O --&gt; P["Wait 1-5s"]
  P --&gt; Q["GraphQL orderCancel (retry)"]
  N --&gt;|no| R["Done"]
  Q --&gt; S{Errors remain?}
  S --&gt;|yes| T["Escalate / log"]
  S --&gt;|no| R

  R --&gt; U["Send email via Outlook node"]
</code></pre>

<h2 id="key-implementation-notes">Key implementation notes</h2>

<ul>
  <li>The workflow file in this repository shows the exact node graph: <code class="language-plaintext highlighter-rouge">Shopify - Cancel SEARCHANISE_IGNORE Only Orders.json</code>.</li>
  <li>We use Shopify GraphQL API <code class="language-plaintext highlighter-rouge">2025-07</code> with header‚Äëauth in n8n.</li>
  <li>Core mutations:</li>
</ul>

<div class="language-graphql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">mutation</span><span class="w"> </span><span class="n">OrderCancel</span><span class="p">(</span><span class="w">
  </span><span class="nv">$orderId</span><span class="p">:</span><span class="w"> </span><span class="nb">ID</span><span class="p">!,</span><span class="w">
  </span><span class="nv">$notifyCustomer</span><span class="p">:</span><span class="w"> </span><span class="nb">Boolean</span><span class="p">,</span><span class="w">
  </span><span class="nv">$refundMethod</span><span class="p">:</span><span class="w"> </span><span class="n">OrderCancelRefundMethodInput</span><span class="p">!,</span><span class="w">
  </span><span class="nv">$restock</span><span class="p">:</span><span class="w"> </span><span class="nb">Boolean</span><span class="p">!,</span><span class="w">
  </span><span class="nv">$reason</span><span class="p">:</span><span class="w"> </span><span class="n">OrderCancelReason</span><span class="p">!,</span><span class="w">
  </span><span class="nv">$staffNote</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="w">
</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">orderCancel</span><span class="p">(</span><span class="w">
    </span><span class="n">orderId</span><span class="p">:</span><span class="w"> </span><span class="nv">$orderId</span><span class="p">,</span><span class="w">
    </span><span class="n">notifyCustomer</span><span class="p">:</span><span class="w"> </span><span class="nv">$notifyCustomer</span><span class="p">,</span><span class="w">
    </span><span class="n">refundMethod</span><span class="p">:</span><span class="w"> </span><span class="nv">$refundMethod</span><span class="p">,</span><span class="w">
    </span><span class="n">restock</span><span class="p">:</span><span class="w"> </span><span class="nv">$restock</span><span class="p">,</span><span class="w">
    </span><span class="n">reason</span><span class="p">:</span><span class="w"> </span><span class="nv">$reason</span><span class="p">,</span><span class="w">
    </span><span class="n">staffNote</span><span class="p">:</span><span class="w"> </span><span class="nv">$staffNote</span><span class="w">
  </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">userErrors</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">field</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="p">}</span><span class="w">
    </span><span class="n">orderCancelUserErrors</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">field</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<div class="language-graphql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">mutation</span><span class="w"> </span><span class="n">fulfillmentCancel</span><span class="p">(</span><span class="nv">$id</span><span class="p">:</span><span class="w"> </span><span class="nb">ID</span><span class="p">!)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">fulfillmentCancel</span><span class="p">(</span><span class="n">id</span><span class="p">:</span><span class="w"> </span><span class="nv">$id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">fulfillment</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="p">}</span><span class="w">
    </span><span class="n">userErrors</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">field</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>Warranty/auxiliary products are identified by product tags that include <code class="language-plaintext highlighter-rouge">SEARCHANISE_IGNORE</code>.</li>
  <li>Throttling: brief waits between cancellation calls to avoid API rate limits.</li>
  <li>Notification: the Outlook node emails a summary to the operations mailbox.</li>
</ul>

<h2 id="outcomes">Outcomes</h2>

<ul>
  <li>Malicious warranty‚Äëonly orders are cancelled quickly and consistently, without blocking on fulfillment states.</li>
  <li>No more conflicts with Shopify High‚Äërisk auto‚Äëcancel flows.</li>
  <li>Lower manual review load for support and finance.</li>
</ul>]]></content><author><name>Zinus Engineering</name></author><category term="shopify" /><category term="n8n" /><category term="automation" /><category term="graphql" /><category term="anti-fraud" /><summary type="html"><![CDATA[Replacing Shopify Flow with n8n using GraphQL to cancel $0 or low‚Äëvalue protection plan orders (Mulberry, Route) created by bots]]></summary></entry><entry><title type="html">Welcome to the Zinus Engineering Blog</title><link href="http://localhost:4000/Zinus/posts/2025/01/01/welcome-to-zinus-engineering/" rel="alternate" type="text/html" title="Welcome to the Zinus Engineering Blog" /><published>2025-01-01T00:00:00+09:00</published><updated>2025-01-01T00:00:00+09:00</updated><id>http://localhost:4000/Zinus/posts/2025/01/01/welcome-to-zinus-engineering</id><content type="html" xml:base="http://localhost:4000/Zinus/posts/2025/01/01/welcome-to-zinus-engineering/"><![CDATA[<p>Thanks for stopping by the Zinus Engineering blog. Here we share insights from building real products‚Äîwhat worked, what didn‚Äôt, and how we improve our systems and practices over time.</p>

<p>In the coming months, expect posts about:</p>

<ul>
  <li>Designing cloud infrastructure and data pipelines</li>
  <li>Frontend performance and accessibility</li>
  <li>Test automation and CI/CD for higher product quality</li>
</ul>

<p>We look forward to learning together.</p>]]></content><author><name>Zinus Engineering</name></author><category term="announcement" /><category term="culture" /><summary type="html"><![CDATA[Intro to our engineering blog and how we plan to use it]]></summary></entry></feed>